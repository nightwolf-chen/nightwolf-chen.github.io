<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>最近在做一个视频相关的项目。一开始我们使用开源播放器，遇到不少坑，以至于我要深入去研究一下播放器的原理和实现。我在这个过程中用C实现了一个简单的Player，这里总结记录一下。
</code></pre></div></div>
<p>完整的demo源码<a href="https://github.com/nightwolf-chen/JDCFFPlayer">GitHub</a>。</p>
<h2 id="播放器原理简介">播放器原理简介</h2>

<p>视频的播放我们要从视频文件说起。视频文件可以简单的理解为主要的两个流（当然还有额外的信息):视频流和音频流。视频流也可以简单的理解为是连续的图片帧编码而成的，具体的编码算法那就博大精深了，比如现在市面上比较流行的h264，不过这些编解码算法mmfpeg都已经封装成库了。音频流就是可以播放的音频了，是声音采样信号PCM经过一定的编码的数据流，比较常见的有aac。</p>

<p>明白了视频文件的结构，我们就有了一个很直接的的播放流程：将视频流解码出来逐帧播放与此同时播放声音流，我们需要特别注意的就是视频和音频的同步的问题，视频文件里面包含了足够的信息让我么来进行同步。
是播放的流程如图：
<img src="/_image/2017-04-10 ffmpeg+sdl2.0/Player.jpg" alt="" /></p>

<h2 id="ffmpegsdl20">FFmpeg+SDL2.0</h2>
<p>SDL是Simple Direct Media Layer，是C实现的跨平台底层库，我在播放器实现里主要使用到他的图像渲染以及音频能力。
我重点关注解码以及同步实现。我需要几个主要线程来运行不同的任务。</p>
<blockquote>
  <ul>
    <li>视频解包线程(decode_thread)：这个线程将视频文件进行解包，将视频流和音频流解析成packet，然后分发到视频解码线程和音频解码线程。</li>
    <li>视频解码线程(video_thread):这个线程进行实际的视频解码操作，将packet解码成实际的AVFrame，然后交个渲染层。</li>
    <li>音频线程(audio_thread):SDL音频本运行在一个独立线程，我们需要实现相关回调为其提供数据。</li>
  </ul>
</blockquote>

<p>在播放器里面我创建了三个队列，需要在这里说明一下，以防混淆。</p>

<table>
  <thead>
    <tr>
      <th>队列名称</th>
      <th>队列作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Video Packet队列（videoQueue)</td>
      <td>存放从视频文件中直接读取出来的视频packet包数据。</td>
    </tr>
    <tr>
      <td>Audio Packet队列（audioQueue)</td>
      <td>存放从视频文件中直接读取出来的音频packet包数据。</td>
    </tr>
    <tr>
      <td>Video Frame队列（videoFrameQueue)</td>
      <td>视频帧队列存放的是已经解码完成的视频帧数据。</td>
    </tr>
  </tbody>
</table>

<h3 id="ffmpeg-解码流程">FFmpeg 解码流程</h3>
<p>首先定义一个存储播放器上下文的结构体：</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">JDCMediaContext</span> <span class="p">{</span>
    
    <span class="n">AVFormatContext</span> <span class="o">*</span><span class="n">fmtCtx</span><span class="p">;</span><span class="c1">//视频文件上下文</span>
    
    <span class="n">AVCodec</span> <span class="o">*</span><span class="n">codecVideo</span><span class="p">;</span><span class="c1">//视频解码器</span>
    <span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">codecCtxVideo</span><span class="p">;</span><span class="c1">//视频解码上下文</span>
    <span class="n">AVStream</span> <span class="o">*</span><span class="n">videoStream</span><span class="p">;</span><span class="c1">//视频流</span>
    <span class="kt">int</span> <span class="n">videoStreamIdx</span><span class="p">;</span><span class="c1">//视频流在format的index    </span>
    
    <span class="n">AVCodec</span> <span class="o">*</span><span class="n">codecAudio</span><span class="p">;</span><span class="c1">//音频解码器</span>
    <span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">codecCtxAudio</span><span class="p">;</span><span class="c1">//音频解码上下文</span>
    <span class="n">AVStream</span> <span class="o">*</span><span class="n">audioStream</span><span class="p">;</span><span class="c1">//音频流</span>
    <span class="kt">int</span> <span class="n">audioStreamIdx</span><span class="p">;</span><span class="c1">//音频流在format的indx    </span>
    
    <span class="n">JDCSDLContext</span> <span class="o">*</span><span class="n">sdlCtx</span><span class="p">;</span><span class="c1">//SDL2.0 上下文</span>
    
    <span class="n">SDL_Thread</span> <span class="o">*</span><span class="n">parse_tid</span><span class="p">;</span><span class="c1">//解包线程tid    </span>
    <span class="n">SDL_Thread</span> <span class="o">*</span><span class="n">video_tid</span><span class="p">;</span><span class="c1">//视频解码线程tid    </span>
    
    <span class="k">struct</span> <span class="n">SwsContext</span> <span class="o">*</span><span class="n">swsCtx</span><span class="p">;</span><span class="c1">//AVFrame变换上线文</span>
    <span class="n">JDCSDLPacketQueue</span> <span class="o">*</span><span class="n">audioQueue</span><span class="p">;</span><span class="c1">//音频packet队列</span>
    <span class="n">JDCSDLPacketQueue</span> <span class="o">*</span><span class="n">videoQueue</span><span class="p">;</span><span class="c1">//视频packet队列</span>
    
    <span class="n">JDCSDLPacketQueue</span> <span class="o">*</span><span class="n">videoFrameQueue</span><span class="p">;</span><span class="c1">//解码完成的视频帧队列</span>
    
    <span class="kt">char</span> <span class="n">filename</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span><span class="c1">//文件名</span>
    
    <span class="kt">int</span> <span class="n">quit</span><span class="p">;</span><span class="c1">//退出标志</span>
<span class="p">};</span>
</code></pre></div></div>
<h4 id="打开视频文件">打开视频文件</h4>
<p>首先我们需要打开一个视频文件：</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">JDCMediaContext</span> <span class="o">*</span><span class="nf">jdc_media_open_input</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">url</span><span class="p">,</span><span class="n">JDCError</span> <span class="o">**</span><span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">JDCMediaContext</span> <span class="o">*</span><span class="n">mCtx</span> <span class="o">=</span> <span class="p">(</span><span class="n">JDCMediaContext</span> <span class="o">*</span><span class="p">)</span><span class="n">av_mallocz</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">JDCMediaContext</span><span class="p">));</span>
    <span class="n">AVFormatContext</span> <span class="o">*</span><span class="n">pFmtCtx</span> <span class="o">=</span> <span class="n">avformat_alloc_context</span><span class="p">();</span>
    
    <span class="n">strcpy</span><span class="p">(</span><span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">,</span> <span class="n">url</span><span class="p">);</span>
    <span class="c1">//打开一个视频文件</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">avformat_open_input</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pFmtCtx</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">av_free</span><span class="p">(</span><span class="n">mCtx</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">fmtCtx</span> <span class="o">=</span> <span class="n">pFmtCtx</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">avformat_find_stream_info</span><span class="p">(</span><span class="n">pFmtCtx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">av_free</span><span class="p">(</span><span class="n">mCtx</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// Dump information about file onto standard error</span>
    <span class="n">av_dump_format</span><span class="p">(</span><span class="n">pFmtCtx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">//找到文件中的视频流和音频流    </span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pFmtCtx</span><span class="o">-&gt;</span><span class="n">nb_streams</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pFmtCtx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">codecpar</span><span class="o">-&gt;</span><span class="n">codec_type</span> <span class="o">==</span> <span class="n">AVMEDIA_TYPE_VIDEO</span> <span class="o">&amp;&amp;</span>
           <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">videoStream</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
            <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">videoStreamIdx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="k">if</span><span class="p">(</span><span class="n">pFmtCtx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">codecpar</span><span class="o">-&gt;</span><span class="n">codec_type</span> <span class="o">==</span> <span class="n">AVMEDIA_TYPE_AUDIO</span> <span class="o">&amp;&amp;</span>
           <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">audioStream</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
            <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">audioStreamIdx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    
    <span class="k">return</span> <span class="n">mCtx</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="做好解码准备">做好解码准备</h4>
<p>找到视频流和音频流以后我们需要找到对应的解码器并且打开流，做好解码的准备。</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">jdc_media_open_stream</span><span class="p">(</span><span class="n">mCtx</span><span class="p">,</span> <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">audioStreamIdx</span><span class="p">);</span>
<span class="n">jdc_media_open_stream</span><span class="p">(</span><span class="n">mCtx</span><span class="p">,</span> <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">videoStreamIdx</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">jdc_media_open_stream</span><span class="p">(</span><span class="n">JDCMediaContext</span> <span class="o">*</span><span class="n">mCtx</span> <span class="p">,</span> <span class="kt">int</span> <span class="n">sIdx</span><span class="p">){</span>
    
    <span class="n">AVFormatContext</span> <span class="o">*</span><span class="n">pFormatCtx</span> <span class="o">=</span> <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">fmtCtx</span><span class="p">;</span>
    <span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">codecCtx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">AVCodec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">sIdx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">sIdx</span> <span class="o">&gt;=</span> <span class="n">pFormatCtx</span><span class="o">-&gt;</span><span class="n">nb_streams</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">AVStream</span> <span class="o">*</span><span class="n">stream</span> <span class="o">=</span> <span class="n">pFormatCtx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">sIdx</span><span class="p">];</span>
    <span class="c1">//找到解码器</span>
    <span class="n">codec</span> <span class="o">=</span> <span class="n">avcodec_find_decoder</span><span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">codecpar</span><span class="o">-&gt;</span><span class="n">codec_id</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">codec</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Unsupported codec!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">codecCtx</span> <span class="o">=</span> <span class="n">avcodec_alloc_context3</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
    <span class="c1">//配置解码上下文</span>
    <span class="k">if</span><span class="p">(</span><span class="n">avcodec_parameters_to_context</span><span class="p">(</span><span class="n">codecCtx</span><span class="p">,</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">codecpar</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"avcodec parameters to context failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//SDL 音频配置    </span>
    <span class="k">if</span> <span class="p">(</span><span class="n">codecCtx</span><span class="o">-&gt;</span><span class="n">codec_type</span> <span class="o">==</span> <span class="n">AVMEDIA_TYPE_AUDIO</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">SDL_AudioSpec</span> <span class="n">wanted_spec</span><span class="p">;</span>
        <span class="n">SDL_AudioSpec</span> <span class="n">spec</span><span class="p">;</span>
        <span class="n">wanted_spec</span><span class="p">.</span><span class="n">freq</span> <span class="o">=</span> <span class="n">codecCtx</span><span class="o">-&gt;</span><span class="n">sample_rate</span><span class="p">;</span>
        <span class="n">wanted_spec</span><span class="p">.</span><span class="n">format</span> <span class="o">=</span> <span class="n">AUDIO_S16SYS</span><span class="p">;</span>
        <span class="n">wanted_spec</span><span class="p">.</span><span class="n">channels</span> <span class="o">=</span> <span class="n">codecCtx</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">;</span>
        <span class="n">wanted_spec</span><span class="p">.</span><span class="n">silence</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">wanted_spec</span><span class="p">.</span><span class="n">samples</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
        <span class="c1">//音频回调，我在这个回调中向音频设备feed数据。</span>
        <span class="n">wanted_spec</span><span class="p">.</span><span class="n">callback</span> <span class="o">=</span> <span class="n">jdc_sdl_audio_callback</span><span class="p">;</span>
        <span class="n">wanted_spec</span><span class="p">.</span><span class="n">userdata</span> <span class="o">=</span> <span class="n">mCtx</span><span class="p">;</span>
        
        <span class="k">if</span><span class="p">(</span><span class="n">SDL_OpenAudio</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wanted_spec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spec</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"SDL_OpenAudio: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">SDL_GetError</span><span class="p">());</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">//打开流开始解码</span>
    <span class="k">if</span><span class="p">(</span><span class="n">avcodec_open2</span><span class="p">(</span><span class="n">codecCtx</span><span class="p">,</span> <span class="n">codec</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Unsupported codec!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">switch</span><span class="p">(</span><span class="n">codecCtx</span><span class="o">-&gt;</span><span class="n">codec_type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">AVMEDIA_TYPE_AUDIO</span><span class="p">:</span>
            <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">audioStreamIdx</span> <span class="o">=</span> <span class="n">sIdx</span><span class="p">;</span>
            <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">audioStream</span> <span class="o">=</span> <span class="n">stream</span><span class="p">;</span>
            <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">codecAudio</span> <span class="o">=</span> <span class="n">codec</span><span class="p">;</span>
            <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">codecCtxAudio</span> <span class="o">=</span> <span class="n">codecCtx</span><span class="p">;</span>
            <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">audioQueue</span> <span class="o">=</span> <span class="n">jdc_packet_queue_alloc</span><span class="p">();</span>
            <span class="n">jdc_packet_queue_init</span><span class="p">(</span><span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">audioQueue</span><span class="p">);</span>
            <span class="n">SDL_PauseAudio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">AVMEDIA_TYPE_VIDEO</span><span class="p">:</span>
            <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">videoStreamIdx</span> <span class="o">=</span> <span class="n">sIdx</span><span class="p">;</span>
            <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">videoStream</span> <span class="o">=</span> <span class="n">stream</span><span class="p">;</span>
            <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">codecVideo</span> <span class="o">=</span> <span class="n">codec</span><span class="p">;</span>
            <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">codecCtxVideo</span> <span class="o">=</span> <span class="n">codecCtx</span><span class="p">;</span>
            <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">videoQueue</span> <span class="o">=</span> <span class="n">jdc_packet_queue_alloc</span><span class="p">();</span>
            <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">video_tid</span> <span class="o">=</span> <span class="n">SDL_CreateThread</span><span class="p">(</span><span class="n">jdc_media_video_thread</span><span class="p">,</span>
                                               <span class="s">"video thread"</span><span class="p">,</span>
                                               <span class="n">mCtx</span><span class="p">);</span>
            <span class="n">jdc_packet_queue_init</span><span class="p">(</span><span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">videoQueue</span><span class="p">);</span>
            <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">swsCtx</span> <span class="o">=</span> <span class="n">sws_getContext</span><span class="p">(</span><span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">codecCtxVideo</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span>
                                           <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">codecCtxVideo</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">,</span>
                                           <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">codecCtxVideo</span><span class="o">-&gt;</span><span class="n">pix_fmt</span><span class="p">,</span>
                                           <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">codecCtxVideo</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span>
                                           <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">codecCtxVideo</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">,</span>
                                           <span class="n">AV_PIX_FMT_YUV420P</span><span class="p">,</span>
                                           <span class="n">SWS_BILINEAR</span><span class="p">,</span>
                                           <span class="nb">NULL</span><span class="p">,</span>
                                           <span class="nb">NULL</span><span class="p">,</span>
                                           <span class="nb">NULL</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>
<h4 id="从视频当中读取数据">从视频当中读取数据</h4>

<p>配置好解码上下文以后，我们开一个线程专门从视频视频文件里面读取packet，我们将读取到的packet分别放到视频packet队列和音频packet队列。队列的实现我在另一篇文章中讨论:<a href="http://www.jidongchen.com/post/2017-04-13-tong-yong-dui-lie-shi-xian">通用队列实现链接</a>。</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//这里我用的是SDL的线程创建接口，也可以用标准的pthread接口实现。</span>
 <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">parse_tid</span> <span class="o">=</span> <span class="n">SDL_CreateThread</span><span class="p">(</span><span class="n">jdc_media_decode_thread</span><span class="p">,</span> <span class="s">"decode thread"</span><span class="p">,</span><span class="n">mCtx</span><span class="p">);</span>
 <span class="c1">//线程运行的方法</span>
 <span class="kt">int</span> <span class="nf">jdc_media_decode_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">userData</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">JDCMediaContext</span> <span class="o">*</span><span class="n">mCtx</span> <span class="o">=</span> <span class="n">userData</span><span class="p">;</span>
    <span class="n">AVFrame</span> <span class="o">*</span><span class="n">pFrame</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">pFrame</span> <span class="o">=</span> <span class="n">av_frame_alloc</span><span class="p">();</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">pFrame</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">int</span> <span class="n">numBytes</span><span class="p">;</span>
    <span class="n">numBytes</span> <span class="o">=</span> <span class="n">av_image_get_buffer_size</span><span class="p">(</span><span class="n">AV_PIX_FMT_YUV420P</span><span class="p">,</span>
                                        <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">codecCtxVideo</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span>
                                        <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">codecCtxVideo</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">,</span>
                                        <span class="mi">1</span><span class="p">);</span>
    <span class="n">AVPacket</span> <span class="o">*</span><span class="n">packet</span><span class="p">;</span>

    <span class="c1">//这个方法的核心就是不断的读取视频文件数据，存储到AVPacket结构</span>
    <span class="c1">//视频则放到视频packet队列，音频则放到音频packet队列。    </span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">do</span><span class="p">{</span>
        <span class="n">packet</span> <span class="o">=</span> <span class="n">av_packet_alloc</span><span class="p">();</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">av_read_frame</span><span class="p">(</span><span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">fmtCtx</span><span class="p">,</span> <span class="n">packet</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">stream_index</span> <span class="o">==</span> <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">videoStream</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">jdc_packet_queue_push</span><span class="p">(</span><span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">videoQueue</span><span class="p">,</span> <span class="n">packet</span><span class="p">);</span>
            <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">stream_index</span> <span class="o">==</span> <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">audioStream</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">){</span>
                <span class="n">jdc_packet_queue_push</span><span class="p">(</span><span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">audioQueue</span><span class="p">,</span> <span class="n">packet</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
    
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="解码数据">解码数据</h4>
<p>从视频文件拿到的packet需要经过解码才能拿到实际的帧数据AVFrame，我们已经把视频和音频packet分别放到了两个队列。针对视频我需要一个专门进行解码操作，这个线程将解码得到的AVFrame放到一个专门的视频帧队列。播放器主线程从视频帧拿到数据进行渲染。</p>
<pre><code class="language-C">int jdc_media_video_thread(void *data)
{
    JDCMediaContext *mCtx = data;
    mCtx-&gt;videoFrameQueue = jdc_packet_queue_alloc();
    jdc_packet_queue_init(mCtx-&gt;videoFrameQueue);
    
    while(1){
        
        AVFrame *pFrame = av_frame_alloc();
        AVPacket *packet;
        //这个方法从视频packet队列里面取出一个packet进行解码，注意如果队列为空这里会
        //挂起，packet新加到队列则会唤醒此线程。
        if(jdc_packet_queue_get_packet(mCtx-&gt;videoQueue, (void **)&amp;packet, 1) &lt; 0) {
            break;
        }
        
         //将packet数据送给解码器。
         int r = avcodec_send_packet(mCtx-&gt;codecCtxVideo, packet);
         if (r != 0) {
            av_packet_unref(packet);
            av_packet_free(&amp;packet);
             continue;
         }
        //尝试获取解码结果        
         r = avcodec_receive_frame(mCtx-&gt;codecCtxVideo, pFrame);
         if (r != 0) {
            av_packet_unref(packet);
            av_packet_free(&amp;packet);
             continue;
         }
        //解码成功，将解码好的视频帧数据放到帧队列。        
        jdc_packet_queue_push(mCtx-&gt;videoFrameQueue, pFrame);
        av_packet_unref(packet);
        av_packet_free(&amp;packet);
    }
    
    
    return 0;
} 
</code></pre>
<p>到这里，我们已经完成了视频帧的解码，得到了渲染需要的数据。音频的数据解码，我们将在SDL的音频线程进行。现在我们进入数据呈现的实现。</p>
<h3 id="使用sdl-20进行视频呈现">使用SDL 2.0进行视频呈现</h3>
<h4 id="sdl-图像渲染">SDL 图像渲染</h4>
<h5 id="始化sdl组件">始化SDL组件</h5>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">jdc_sdl_init</span><span class="p">(){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">SDL_Init</span><span class="p">(</span><span class="n">SDL_INIT_VIDEO</span> <span class="o">|</span> <span class="n">SDL_INIT_AUDIO</span> <span class="o">|</span> <span class="n">SDL_INIT_TIMER</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h5 id="创建用于显示的window">创建用于显示的window</h5>
<p>SDL在iOS平台使用UIWindow实现Window，我这里调用SDL提供的接口创建Window。</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">SDL_Window</span> <span class="o">*</span><span class="n">window</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    
    <span class="n">window</span> <span class="o">=</span> <span class="n">SDL_CreateWindow</span><span class="p">(</span><span class="s">"video"</span><span class="p">,</span>
                              <span class="n">SDL_WINDOWPOS_UNDEFINED</span><span class="p">,</span>
                              <span class="n">SDL_WINDOWPOS_UNDEFINED</span><span class="p">,</span>
                              <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">codecCtxVideo</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span>
                              <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">codecCtxVideo</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">,</span>
                              <span class="n">SDL_WINDOW_ALLOW_HIGHDPI</span> <span class="o">|</span> <span class="n">SDL_WINDOW_OPENGL</span> <span class="o">|</span><span class="n">SDL_WINDOW_BORDERLESS</span><span class="p">);</span>
</code></pre></div></div>
<h5 id="给window配置渲染方式和texture">给window配置渲染方式和Texture</h5>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">SDL_Renderer</span> <span class="o">*</span><span class="n">pRenderer</span> <span class="o">=</span> <span class="n">SDL_CreateRenderer</span><span class="p">(</span><span class="n">sdlCtx</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pRenderer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">av_free</span><span class="p">(</span><span class="n">sdlCtx</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">sdlCtx</span><span class="o">-&gt;</span><span class="n">renderer</span> <span class="o">=</span> <span class="n">pRenderer</span><span class="p">;</span>
    <span class="c1">//注意这里我们使用YUV格式</span>
    <span class="n">SDL_Texture</span> <span class="o">*</span><span class="n">pTexture</span> <span class="o">=</span> <span class="n">SDL_CreateTexture</span><span class="p">(</span><span class="n">pRenderer</span><span class="p">,</span>
                                              <span class="n">SDL_PIXELFORMAT_IYUV</span><span class="p">,</span>
                                              <span class="n">SDL_TEXTUREACCESS_STREAMING</span><span class="p">,</span>
                                              <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">codecCtxVideo</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span>
                                              <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">codecCtxVideo</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pTexture</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">av_free</span><span class="p">(</span><span class="n">sdlCtx</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">SDL_SetTextureBlendMode</span><span class="p">(</span><span class="n">pTexture</span><span class="p">,</span><span class="n">SDL_BLENDMODE_BLEND</span><span class="p">);</span>
</code></pre></div></div>

<h5 id="实现渲染方法">实现渲染方法</h5>
<p>真正的将视频绘制到window上，我们拿到AVFrame即可。</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">video_display</span><span class="p">(</span><span class="n">JDCMediaContext</span> <span class="o">*</span><span class="n">mCtx</span> <span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="n">AVFrame</span> <span class="o">*</span><span class="n">pFrameYUV</span> <span class="o">=</span> <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">sdlCtx</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">;</span>

    <span class="n">AVFrame</span> <span class="o">*</span><span class="n">pFrame</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">JDCSDLContext</span> <span class="o">*</span><span class="n">sdlCtx</span> <span class="o">=</span> <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">sdlCtx</span><span class="p">;</span>
    
    <span class="k">struct</span> <span class="n">SwsContext</span> <span class="o">*</span><span class="n">swsCtx</span> <span class="o">=</span> <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">swsCtx</span><span class="p">;</span>
    
    <span class="n">sws_scale</span><span class="p">(</span><span class="n">swsCtx</span><span class="p">,</span>
              <span class="p">(</span><span class="kt">uint8_t</span>  <span class="k">const</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span><span class="p">)</span><span class="n">pFrame</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
              <span class="n">pFrame</span><span class="o">-&gt;</span><span class="n">linesize</span><span class="p">,</span>
              <span class="mi">0</span><span class="p">,</span>
              <span class="n">pFrame</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">,</span>
              <span class="n">pFrameYUV</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
              <span class="n">pFrameYUV</span><span class="o">-&gt;</span><span class="n">linesize</span><span class="p">);</span>
    
    <span class="n">SDL_Rect</span> <span class="n">sdlRect</span><span class="p">;</span>
    <span class="n">sdlRect</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">sdlRect</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">sdlRect</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">pFrame</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">;</span>
    <span class="n">sdlRect</span><span class="p">.</span><span class="n">h</span> <span class="o">=</span> <span class="n">pFrame</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>
    
    <span class="n">SDL_UpdateYUVTexture</span><span class="p">(</span><span class="n">sdlCtx</span><span class="o">-&gt;</span><span class="n">texture</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sdlRect</span><span class="p">,</span>
                         <span class="n">pFrameYUV</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pFrameYUV</span><span class="o">-&gt;</span><span class="n">linesize</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                         <span class="n">pFrameYUV</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pFrameYUV</span><span class="o">-&gt;</span><span class="n">linesize</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                         <span class="n">pFrameYUV</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">pFrameYUV</span><span class="o">-&gt;</span><span class="n">linesize</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
    
    <span class="n">SDL_RenderClear</span><span class="p">(</span><span class="n">sdlCtx</span><span class="o">-&gt;</span><span class="n">renderer</span> <span class="p">);</span>
    <span class="n">SDL_RenderCopy</span><span class="p">(</span> <span class="n">sdlCtx</span><span class="o">-&gt;</span><span class="n">renderer</span><span class="p">,</span> <span class="n">sdlCtx</span><span class="o">-&gt;</span><span class="n">texture</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sdlRect</span> <span class="p">);</span>
    <span class="n">SDL_RenderPresent</span><span class="p">(</span> <span class="n">sdlCtx</span><span class="o">-&gt;</span><span class="n">renderer</span> <span class="p">);</span>
    
    <span class="n">av_frame_unref</span><span class="p">(</span><span class="n">pFrame</span><span class="p">);</span>
    <span class="n">av_frame_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pFrame</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h5 id="视频主循环">视频主循环</h5>
<p>接下来我们只需一个timer定时触发事件，从视频帧队列里面拿出数据，绘制到屏幕上即可。</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
        
        <span class="n">SDL_WaitEvent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
        <span class="k">switch</span><span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="n">FF_QUIT_EVENT</span><span class="p">:</span>
            <span class="k">case</span> <span class="n">SDL_QUIT</span><span class="p">:</span>
                <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">quit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">SDL_Quit</span><span class="p">();</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="n">FF_REFRESH_EVENT</span><span class="p">:</span>
                <span class="n">video_refresh_timer</span><span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">user</span><span class="p">.</span><span class="n">data1</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">default</span><span class="o">:</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">video_refresh_timer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">userdata</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="n">JDCMediaContext</span> <span class="o">*</span><span class="n">mCtx</span> <span class="o">=</span> <span class="p">(</span><span class="n">JDCMediaContext</span> <span class="o">*</span><span class="p">)</span><span class="n">userdata</span><span class="p">;</span>
    
    <span class="k">if</span><span class="p">(</span><span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">videoStream</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">jdc_packet_queue_size</span><span class="p">(</span><span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">videoFrameQueue</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">schedule_refresh</span><span class="p">(</span><span class="n">mCtx</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">//这个方法设定timer下一次触发的时间间隔</span>
            <span class="c1">//现在我们不考虑同步问题，设定一个估计值。</span>
            <span class="n">schedule_refresh</span><span class="p">(</span><span class="n">mCtx</span><span class="p">,</span> <span class="mi">40</span><span class="p">);</span>
            <span class="kt">void</span> <span class="o">*</span><span class="n">videoFrameData</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="c1">//从帧队列拿出帧数据，如果没有则挂起直到有新的frame数据。</span>
            <span class="n">jdc_packet_queue_get_packet</span><span class="p">(</span><span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">videoFrameQueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">videoFrameData</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">video_display</span><span class="p">(</span><span class="n">mCtx</span><span class="p">,</span><span class="n">videoFrameData</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">schedule_refresh</span><span class="p">(</span><span class="n">mCtx</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="sdl-音频解码与播放">SDL 音频解码与播放</h4>
<p>简单来说，使用SDL播放音频有以下几个步骤:</p>
<blockquote>
  <ul>
    <li>打开音频设备，设置回调。</li>
    <li>在回调里面feed音频数据。</li>
  </ul>
</blockquote>

<p>实际上，我们之前拿到的音频数据还是AVPacket，我们需要在想音频设备feed之前对其先进行解码。</p>

<h5 id="打开音频设备">打开音频设备</h5>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">SDL_AudioSpec</span> <span class="n">wantedSpec</span><span class="p">;</span>
    <span class="n">SDL_AudioSpec</span> <span class="n">obtainedSpec</span><span class="p">;</span>
    
    <span class="n">wantedSpec</span><span class="p">.</span><span class="n">freq</span> <span class="o">=</span> <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">audioStream</span><span class="o">-&gt;</span><span class="n">codecpar</span><span class="o">-&gt;</span><span class="n">sample_rate</span><span class="p">;</span>
    <span class="n">wantedSpec</span><span class="p">.</span><span class="n">format</span> <span class="o">=</span> <span class="n">AUDIO_S16</span><span class="p">;</span>
    <span class="n">wantedSpec</span><span class="p">.</span><span class="n">channels</span> <span class="o">=</span> <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">codecCtxAudio</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">;</span>
    <span class="n">wantedSpec</span><span class="p">.</span><span class="n">silence</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">wantedSpec</span><span class="p">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">SDL_AUDIO_BUFFER_SIZE</span><span class="p">;</span>
    <span class="n">wantedSpec</span><span class="p">.</span><span class="n">callback</span> <span class="o">=</span> <span class="n">jdc_sdl_audio_callback</span><span class="p">;</span><span class="c1">//回调方法</span>
    <span class="n">wantedSpec</span><span class="p">.</span><span class="n">userdata</span> <span class="o">=</span> <span class="n">mCtx</span><span class="p">;</span>
    
    <span class="k">if</span><span class="p">(</span><span class="n">SDL_OpenAudio</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wantedSpec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">obtainedSpec</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">av_free</span><span class="p">(</span><span class="n">sdlCtx</span><span class="p">);</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"SDL_OpenAudio: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">SDL_GetError</span><span class="p">());</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">SDL_PauseAudio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

<h5 id="实现音频回调">实现音频回调</h5>
<p>我们在回调里面要做的就是将解码好的数据，按照回调要求的数据量copy到缓冲区就行了。</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//stream是音频设备缓冲区的指针我们往里面填数据，len表示当前设备要求数据的长度。</span>
<span class="c1">//userdata是我们自己的自定义数据.</span>
<span class="kt">void</span> <span class="nf">jdc_sdl_audio_callback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">userdata</span><span class="p">,</span> <span class="n">Uint8</span> <span class="o">*</span> <span class="n">stream</span><span class="p">,</span><span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">JDCMediaContext</span> <span class="o">*</span><span class="n">mCtx</span> <span class="o">=</span> <span class="p">(</span><span class="n">JDCMediaContext</span> <span class="o">*</span><span class="p">)</span><span class="n">userdata</span><span class="p">;</span>
    <span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">codecCtx</span> <span class="o">=</span> <span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">codecCtxAudio</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">len1</span><span class="p">,</span><span class="n">audio_size</span><span class="p">;</span>
    <span class="c1">//用来缓存我们解码好的音频数据。</span>
    <span class="k">static</span> <span class="kt">uint8_t</span> <span class="n">audio_buf</span><span class="p">[</span><span class="mi">192000</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">/</span> <span class="mi">2</span><span class="p">];</span>
    <span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">audio_buf_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">audio_buf_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="k">while</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//标明解码的数据已经用完了，我们需要重新解码一些数据。</span>
        <span class="k">if</span><span class="p">(</span><span class="n">audio_buf_index</span> <span class="o">&gt;=</span> <span class="n">audio_buf_size</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* We have already sent all our data; get more */</span>
            <span class="n">audio_size</span> <span class="o">=</span> <span class="n">jdc_sdl_audio_decode_frame</span><span class="p">(</span><span class="n">codecCtx</span><span class="p">,</span>
                                            <span class="n">audio_buf</span><span class="p">,</span>
                                            <span class="k">sizeof</span><span class="p">(</span><span class="n">audio_buf</span><span class="p">),</span>
                                            <span class="n">mCtx</span><span class="p">);</span>
            <span class="k">if</span><span class="p">(</span><span class="n">audio_size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* If error, output silence */</span>
                <span class="n">audio_buf_size</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
                <span class="n">memset</span><span class="p">(</span><span class="n">audio_buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">audio_buf_size</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">audio_buf_size</span> <span class="o">=</span> <span class="n">audio_size</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">audio_buf_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="n">len1</span> <span class="o">=</span> <span class="n">audio_buf_size</span> <span class="o">-</span> <span class="n">audio_buf_index</span><span class="p">;</span>
        
        <span class="k">if</span><span class="p">(</span><span class="n">len1</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span> <span class="n">len1</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>      
        <span class="c1">//往设备缓冲区填数据。  </span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">audio_buf</span> <span class="o">+</span> <span class="n">audio_buf_index</span><span class="p">,</span> <span class="n">len1</span><span class="p">);</span>
        
        <span class="n">len</span> <span class="o">-=</span> <span class="n">len1</span><span class="p">;</span>
        <span class="n">stream</span> <span class="o">+=</span> <span class="n">len1</span><span class="p">;</span>
        <span class="n">audio_buf_index</span> <span class="o">+=</span> <span class="n">len1</span><span class="p">;</span>
    <span class="p">}</span>
    
<span class="p">}</span>
</code></pre></div></div>
<h5 id="音频数据解码">音频数据解码</h5>
<p>音频数据的解码跟视频数据解码方式基本一致。需要注意的是对于视频数据，一个AVPacket解码出对应一个AVFrame。但是这对于音频数据是不一定的，某些AVPacket可能包含多个frame，这里需要特别处理一下。</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">jdc_sdl_audio_decode_frame</span><span class="p">(</span><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">aCodecCtx</span><span class="p">,</span>
                       <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">audio_buf</span><span class="p">,</span>
                       <span class="kt">int</span> <span class="n">buf_size</span><span class="p">,</span>
                       <span class="n">JDCMediaContext</span> <span class="o">*</span><span class="n">mCtx</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">AVPacket</span> <span class="o">*</span><span class="n">pkt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">AVFrame</span> <span class="n">frame</span><span class="p">;</span>
    
    <span class="kt">int</span> <span class="n">len1</span><span class="p">,</span> <span class="n">data_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">pkt</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">pkt</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            
            <span class="k">if</span>  <span class="p">(</span><span class="n">avcodec_send_packet</span><span class="p">(</span><span class="n">aCodecCtx</span><span class="p">,</span> <span class="n">pkt</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">av_packet_unref</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>
                <span class="n">av_packet_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pkt</span><span class="p">);</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            
            <span class="n">data_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="c1">//用循环处理多个frame的情况</span>
            <span class="k">while</span><span class="p">(</span><span class="n">avcodec_receive_frame</span><span class="p">(</span><span class="n">aCodecCtx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">frame</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">){</span>
                
                <span class="n">len1</span> <span class="o">=</span> <span class="n">frame</span><span class="p">.</span><span class="n">linesize</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
                <span class="k">if</span><span class="p">(</span><span class="n">len1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="cm">/* if error, skip frame */</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                
                <span class="kt">int</span> <span class="n">fData_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">fData_size</span> <span class="o">=</span> <span class="n">av_samples_get_buffer_size</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span>
                                                       <span class="n">aCodecCtx</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">,</span>
                                                       <span class="n">frame</span><span class="p">.</span><span class="n">nb_samples</span><span class="p">,</span>
                                                       <span class="n">aCodecCtx</span><span class="o">-&gt;</span><span class="n">sample_fmt</span><span class="p">,</span>
                                                       <span class="mi">1</span><span class="p">);</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">fData_size</span> <span class="o">&lt;=</span> <span class="n">buf_size</span><span class="p">);</span>
                <span class="c1">//将解码好的数据先存到缓冲区，以便后面使用。</span>
                <span class="n">memcpy</span><span class="p">(</span><span class="n">audio_buf</span><span class="o">+</span><span class="n">data_size</span><span class="p">,</span> <span class="n">frame</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fData_size</span><span class="p">);</span>
                <span class="n">fData_size</span> <span class="o">=</span> <span class="n">AudioResampling</span><span class="p">(</span><span class="n">aCodecCtx</span><span class="p">,</span>
                                             <span class="o">&amp;</span><span class="n">frame</span><span class="p">,</span>
                                             <span class="n">AV_SAMPLE_FMT_S16</span><span class="p">,</span>
                                             <span class="mi">2</span><span class="p">,</span>
                                             <span class="mi">44100</span><span class="p">,</span><span class="n">audio_buf</span><span class="o">+</span><span class="n">data_size</span><span class="p">);</span>
                <span class="n">data_size</span> <span class="o">+=</span> <span class="n">fData_size</span><span class="p">;</span>
            <span class="p">}</span>
            
            <span class="k">if</span> <span class="p">(</span><span class="n">data_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">av_packet_unref</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>
                <span class="n">av_packet_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pkt</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">data_size</span><span class="p">;</span>
            <span class="p">}</span>
            
            <span class="n">av_packet_unref</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>
            <span class="n">av_packet_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pkt</span><span class="p">);</span>
            
        <span class="p">}</span>
        
        <span class="k">if</span><span class="p">(</span><span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">quit</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">//从Audio Queue里面拿packet，如果没有则先挂起直到有数据。</span>
        <span class="k">if</span><span class="p">(</span><span class="n">jdc_packet_queue_get_packet</span><span class="p">(</span><span class="n">mCtx</span><span class="o">-&gt;</span><span class="n">audioQueue</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pkt</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>好了，到这里我们已经实现了音频的播放。</p>

<p>##总结
我在这篇文章里面讨论了如何实现一个简易的播放器，demo可以正常的播放视频，但是没有进度条的功能。播放器的实现思路其实很直接，解码，渲染，同步。目前没有讨论视频同步的问题，我在另外一篇文章中讨论<a href="http://www.jidongchen.com/post/shi-pin-bo-fang-yin-shi-pin-de-tong-bu">视频同步讨论</a>。完整的demo源码请到<a href="https://github.com/nightwolf-chen/JDCFFPlayer">GitHub</a>。</p>
